<div style="display:none;" class="author">
{
    "subtitle": "CCF CSP 题解",
    "title" : "算法",
    "date" : "2025-2026",
    "description": "CCF CSP 题解",
    "tag" : ["技术","算法"]
}
</div>

## 资源
原题测试平台：[Acwing](https://www.acwing.com/) ，仅支持到第33次
官方题解：[CCF数字图书馆](https://dl.ccf.org.cn/index.html)， 搜索“第XX次CCF CSP认证真题精讲”
推荐阅读：《算法竞赛》 （可在个人书架中搜索）

## 第33次CCF计算机软件能力认证
### 第三题 化学方程式配平
[题目描述](https://sim.csp.thusaac.com/contest/33/problem/2)

题解：
第一步，将输入转化为二维数组的形式；第二步，高斯消元；第三步，秩小于未知数个数输出"Y"，反之输出"N"。

一些个人的看法：
配平就是指是否存在非零解，所以可以看作消元后，是否存在一行中有两个及以上的非零元。

代码：
```cpp

#include <bits/stdc++.h>
using namespace std;

double eps = 1e-6;

void gaussian(vector < vector <double>> &arr){
	int h = arr.size() , l = arr[0].size();
	
	for(int i =0;i<min(l,h);i++){
		int mh = i;
		for(int j = i+1 ; j<h;j++) if(fabs(arr[j][i]) > fabs(arr[mh][i])) mh = j;
		swap(arr[i],arr[mh]) ;
		
		if(fabs(arr[i][i]) <=eps) continue;
		
		for(int j = l-1;j>=i;j--) arr[i][j] /= arr[i][i];
	
		for(int j = 0;j<h;j++){
			if(j != i){
				double scale = arr[j][i] / arr[i][i];
				for(int k = 0;k<l;k++) arr[j][k] -= arr[i][k] * scale;
			}
		}
	}
}

void init(vector < vector <double>> &arr){
	int n,ptr=0;
	map <string , int> mp;
	
	cin >> n;
	for(int t = 0;t<n;t++){
		string s;
		int i=0;
		
		cin >> s;
		while(i < s.size()){
			string el = ""; int num = 0;
			while('a' <= s[i]  && s[i] <= 'z') el += s[i++];
			while('0' <= s[i]  && s[i] <= '9') num = num*10+(s[i++]-'0');
			
			if(!mp.count(el)){
				mp[el] = ptr++;
				arr.push_back(vector <double> (n));
			} 
			arr[mp[el]][t] = num;
		}
	}
	return ;
}

int  check(vector < vector <double>> &arr){
	int cnt = 0;
	for(vector <double> i : arr){
		int flag  = 0;
		for(double j : i) {
			if(fabs(j) > eps)  flag += 1;
		}
		if(flag > 1) cnt ++;
	}
	return cnt;
}
int main(){
	int t;
	cin >> t;
	while(t--){
		vector < vector <double> > arr;
		init(arr);
		gaussian(arr);
		if(check(arr) > 0) cout << "Y\n";
		else cout << "N\n"; 
	}
	
}

```

### 第四题 十滴水
[题目描述](https://sim.csp.thusaac.com/contest/33/problem/3)

链表优化写法：
设定全局变量存储有水的格子数；map存储每个格子对应的链表节点，方便修改；起爆后-1。这样是70分。
增加ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)，满分。   

题解：
1. 节点存储格子序号、值、左右节点指针。先用vector存储格子序号和值，排序（因为题目没有说输入是有序的），然后建立链表。
2. 建立map存储格子对应的节点的地址，方便快速访问。
3. 易知加水后要可能要起爆的格子只有当前和左右的格子。加水后，检查当前格子，如果要起爆，先删除该节格子，左右节格子水+1，然后递归检查左右格子。
4. 易知起爆过的格子不会再有水，所以让m表示当前有水的格子数。每起爆一个格子，m-1。每次输出m即可。


代码：

```cpp

#include <bits/stdc++.h>
using namespace std;

typedef struct node {
	int index = 0;
	int value = 0;
	node *left = nullptr;
	node *right = nullptr;
} w , *wp;

int c,m,n;
wp head;
map <int,wp> mp;

void deal_boom(wp aim){ // 递归方式处理左右可能要爆炸的格子
	if(aim == head || aim == nullptr) return ;
	if(aim->value>=5){
		aim->value = 0,m -= 1;
		wp lf = aim->left,rt = aim->right;
		if(lf)	lf->right = aim->right, lf->value +=1;
		if(rt) 	rt->left = aim->left, rt->value +=1;
		
		deal_boom(lf),deal_boom(rt);
	}
	return ;
}
void add_water(int index){ 
	mp[index]->value +=1;
	return ;
}


bool cmp(pair<int,int> a,pair<int,int> b){
	return a.first < b.first;
}

int solve(){
	cin >> c >> m >> n;
	vector <pair<int,int>> v(m);
	for(int i = 0;i<m;i++) cin >> v[i].first >> v[i].second;
	sort(v.begin(),v.end(),cmp);
	
	head = new w();
	wp now = head;
	for(int i = 0;i<m;i++){
		wp new_node = new w { v[i].first,v[i].second, now, nullptr};
		mp[v[i].first] = new_node;
		now->right = new_node;
		now = new_node;
	}

	while(n--){
		int op;
		cin >> op;
		add_water(op);
		deal_boom(mp[op]);
		cout << m << endl;
	}
	return 1;
}

int main(){
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	solve();
	return 0;
}
```


### 第五题 文件夹合并

题解：
合并操作优化是启发式合并，但这道题没有卡这个点，所以遍历即可。

查询深度操作的优化：
每次合并，其所有子节点的深度都-1。对于这种区间操作容易联想到差分，用前缀和获得深度。这样虽然修改使用差分，从O(n)优化为O(1)，但是查询使用前缀和，从O(1)变为O(n)。

这就需要解决两个问题，1. 如何将 树 转化为 数组 ，便于计算差分和前缀和 2. 如何优化前缀和查询

对于1，我们需要用到DFS序，将树转化为数组。
DFS序比较简单，略。

对于2，用`树状数组`来维护差分数组的前缀和。

在本题中，树状数组可视为差分数组的一种“分区“的前缀和数组。它并不直接存储差分数组从第1位到第n位的完整前缀和，而是将差分数组划分为多个区间，每个节点存储一个区间内的部分和。
在查询前缀和时，只需合并若干个互不重叠的区间节点所对应的值；而在修改某一位置时，仅需更新所有包含该位置的区间的节点。这样查询和修改被优化至 O(log n)。
树状数组的构造、查询、修改，请查看 资料P160
我的代码中定义差分数组为每次深度修改的值，所以输出深度时是 nodes[u].depth + change 。


代码：
```cpp

#include <bits/stdc++.h>
using namespace std;

struct node {
    long long data;
    vector<int> children;
    int in, out;
    int depth;
};

vector<node> nodes;
vector<int> tree;
int dfs_time = 0;

void dfs(int u, int dep) {
    nodes[u].in = ++dfs_time;
    nodes[u].depth = dep;

    for (int v :  nodes[u].children) dfs(v, dep + 1);

    nodes[u].out = dfs_time;
}

int lowbit(int x){
	return (x & -x);
}

void add(int x, int v,int n) {
    for (; x <= n; x += lowbit(x)) tree[x] += v;
}

int query(int x) {
    int s = 0;
    for (; x; x -= lowbit(x)) s += tree[x];
    return s;
}

void range_add(int l, int r, int v,int n) {
    add(l, v,n);
    if (r < n) add(r + 1, -v,n);
}


int main() {
    ios::sync_with_stdio(false);cin.tie(0);

    int n, m;
    cin >> n >> m;
    nodes.resize(n + 1);
    tree.resize(n+1,0);

    for (int i = 2; i <= n; i++) {
        int p;
        cin >> p;
        nodes[p].children.push_back(i);
    }

    for (int i = 1; i <= n; i++) cin >> nodes[i].data;

    dfs(1, 1);

    while (m--) {
        int op, u;
        cin >> op >> u;
        if (op == 1) {
			vector <int > new_children;
            for (int child : nodes[u].children) {
            	nodes[u].data += nodes[child].data;

			    for(int grandchild : nodes[child].children) new_children.push_back(grandchild);

			}
			nodes[u].children = new_children;

            for (int v : nodes[u].children) range_add(nodes[v].in, nodes[v].out, -1,n);

            cout << nodes[u].children.size() << " " << nodes[u].data << '\n';
        } 
		else {
            int change = query(nodes[u].in);
            cout << nodes[u].depth + change << '\n';
        }
    }

    return 0;
}
```




## 第37次CCF计算机软件能力认证
### 第三题 模版展开

题解：
- 思路：
    1. 只存储长度即可，无需维护字符串
    2. 递归计算变量长度时，可能过深，每次计算使用记忆化存储
    3. 输入的读入可以用stringstream来实现。

- 踩过的坑：
    1. 一个变量的赋值类型可能改变，注意更新
    2. 更新赋值类型时，要等计算结束后再更新
    3. 记忆化存储每次要清空
    4. 输出记得取模
    5. 间接赋值中也可能存在“字符串”，可以直接加到长度中，计算时加上这部分长度

一些解释：
为方便阅读，我用引号来区分目标变量和 操作变量/操作字符串
1. 递归可能过深：
比如
```
1 a "a"
2 b "$a"
2 c "$b" "$a"
2 d "$a" "$a" "$a"
3 d
```

此时，如果要计算 d，那么a、b会重复计算，所以需要记忆化存储。

2. 更新赋值类型时，要等所有操作结束后再更新
比如
```
1 a "a"
2 b "a" "$a"
1 b "b" "b"
3 b
```
如果直接把b的类型更新为1，那么计算b时就只考虑"a",而没有考虑 "$a"




代码：
```cpp

#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

LL mod = 1000000007;

typedef struct node {
    string name;
    int type; 
    LL length; 
    vector<node *> access; 

    node(string n) : name(n), type(1), length(0) {}
} node;

map<string, node*> mp;
map<string,LL>mp_mem;

LL cnt_var(node* now) {
    if (now->type == 1) return now->length;
    if (mp_mem.count(now->name)) return mp_mem[now->name];
    
    LL sum = now->length;
    for (node* j : now->access) sum = (sum + cnt_var(j)) % mod;
    
    mp_mem[now->name] = sum;
    return sum;
}

vector<string> get_vars() {
    string line,temp;
    getline(cin, line);
    stringstream ss(line);
    vector<string> vars;
    while (ss >> temp) {
        vars.push_back(temp);
    }
    return vars;
}

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        int op;
        string aim;
        cin >> op >> aim;
        if (!mp.count(aim)) mp[aim] = new node(aim);
        
        node* aim_ptr = mp[aim];
        vector<string> vars;
        mp_mem.clear();
        
        if (op == 1 || op == 2) vars = get_vars();
        if (op == 1) {
            LL length = 0;
            for (string j : vars) {
                if (j[0] != '$') length = (length + j.size()) % mod;
                else {
                    j = j.substr(1);
                    if (!mp.count(j)) mp[j] = new node(j);
                    
                    length = (length + cnt_var(mp[j])) % mod;
                }
            }
            aim_ptr->type = 1 , aim_ptr->length = length;
            
        } 
        else if(op==2) {
            LL str_len = 0;
            vector<node*> access_list;
            for (string j : vars) {
                if (j[0] != '$') str_len = (str_len + j.size()) % mod;
                else {
                    j = j.substr(1);
                    if (!mp.count(j)) mp[j] = new node(j);
                    access_list.push_back(mp[j]);
                }
            }
            aim_ptr->type = 2,aim_ptr->length = str_len,aim_ptr->access = access_list;
        } 
        else {
            LL result = cnt_var(aim_ptr);
            cout << result % mod << endl;
        }
    }
    return 0;
}

```


### 第四题 集体锻炼

题解：
（定义 max($arr[i]$) = A）
右端点 r 从 1 到 n 枚举，对于每个右端点 r ，左端点 l 从当前 r 向左移动时，[ l,r ] 区间 gcd值 只会单调非增，每次变化 gcd值 至少减半，最多变化 log A 次，这使左端点取值区间 [ 0,r ] 可以被分成 log A 个连续段。每段内所有点，到 r 形成的区间 的 gcd 值相同。维护一个表示这些连续段的分段列表，记录连续段的左端点和gcd值。<$l _{i},g _{i}$>，然后计算每段的答案的贡献值。

当右端点 r 增加时，需更新分段列表。前一个的分段列表记录的是以 r-1 为右端点的区间。为了将 [l_i, r-1] 扩展为 [l_i, r]，gcd值需更新为gcd(arr[r],g i)，并合并具有相同gcd值的段。

代码：
```cpp

#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

LL gcd(LL a, LL b) {
    while (b) { LL t = b; b = a % b; a = t; }
    return a;
}

const LL mod = 998244353;

int main() {
    int n;
    cin >> n;
    vector<LL> a(n + 1);
    for (int i = 1; i <= n; i++) cin >> a[i];
    
    LL ans = 0;
    vector<pair<LL, LL>> segments; // 段列表: (left, gcd_value)
    
    for (LL r = 1; r <= n; r++) {
        vector<pair<LL, LL>> new_segments;
        LL current_gcd = a[r];
        new_segments.push_back({r, current_gcd});
        
        for (auto &seg : segments) {
            LL g = gcd(seg.second, a[r]);
            if (g == current_gcd) new_segments.back().first = seg.first;
            else new_segments.push_back({seg.first, g});
            
			current_gcd = g;
        }
        segments = new_segments;
        
        LL last = r;
        for (auto &seg : segments) {
            LL left_min = seg.first , g_val = seg.second;
            LL count = last - left_min + 1;
            LL sum_l = (last + left_min) * count / 2 % mod;
            ans = (ans + sum_l * r % mod * g_val % mod) % mod;
            last = left_min - 1;
        }
    }
    cout << ans % mod << endl;
    return 0;
}
```


### 第五题 收费标准评估

