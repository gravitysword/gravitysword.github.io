<div style="display:none;" class="author">
{
    "subtitle": "个人 CCF CSP 题解",
    "title" : "算法",
    "date" : "2025-2026",
    "description": "CCF CSP 题解",
    "tag" : ["技术","算法"]
}
</div>

## 资源
免费原题测试平台：[Acwing](https://www.acwing.com/) ，仅到第33次
付费题目测试平台：[考级100](https://kaoji100.com/#/index)，保持更新
官方题解：[CCF数字图书馆](https://dl.ccf.org.cn/index.html)， 搜索“第XX次CCF CSP认证真题精讲”
推荐阅读：《算法竞赛》 （可在个人书架中搜索）

## 第33次CCF计算机软件能力认证
### 第三题 化学方程式配平
[题目描述](https://sim.csp.thusaac.com/contest/33/problem/2)

题解：
第一步，将输入转化为二维数组的形式；第二步，高斯消元；第三步，秩小于未知数个数输出"Y"，反之输出"N"。

一些个人的看法：
配平就是指是否存在非零解，所以可以看作消元后，是否存在一行中有两个及以上的非零元。

代码：
```cpp

#include <bits/stdc++.h>
using namespace std;

double eps = 1e-6;

void gaussian(vector < vector <double>> &arr){
	int h = arr.size() , l = arr[0].size();
	
	for(int i =0;i<min(l,h);i++){
		int mh = i;
		for(int j = i+1 ; j<h;j++) if(fabs(arr[j][i]) > fabs(arr[mh][i])) mh = j;
		swap(arr[i],arr[mh]) ;
		
		if(fabs(arr[i][i]) <=eps) continue;
		
		for(int j = l-1;j>=i;j--) arr[i][j] /= arr[i][i];
	
		for(int j = 0;j<h;j++){
			if(j != i){
				double scale = arr[j][i] / arr[i][i];
				for(int k = 0;k<l;k++) arr[j][k] -= arr[i][k] * scale;
			}
		}
	}
}

void init(vector < vector <double>> &arr){
	int n,ptr=0;
	map <string , int> mp;
	
	cin >> n;
	for(int t = 0;t<n;t++){
		string s;
		int i=0;
		
		cin >> s;
		while(i < s.size()){
			string el = ""; int num = 0;
			while('a' <= s[i]  && s[i] <= 'z') el += s[i++];
			while('0' <= s[i]  && s[i] <= '9') num = num*10+(s[i++]-'0');
			
			if(!mp.count(el)){
				mp[el] = ptr++;
				arr.push_back(vector <double> (n));
			} 
			arr[mp[el]][t] = num;
		}
	}
	return ;
}

int  check(vector < vector <double>> &arr){
	int cnt = 0;
	for(vector <double> i : arr){
		int flag  = 0;
		for(double j : i) {
			if(fabs(j) > eps)  flag += 1;
		}
		if(flag > 1) cnt ++;
	}
	return cnt;
}
int main(){
	int t;
	cin >> t;
	while(t--){
		vector < vector <double> > arr;
		init(arr);
		gaussian(arr);
		if(check(arr) > 0) cout << "Y\n";
		else cout << "N\n"; 
	}
	
}

```

### 第四题 十滴水
[题目描述](https://sim.csp.thusaac.com/contest/33/problem/3)

链表优化写法：
设定全局变量存储有水的格子数；map存储每个格子对应的链表节点，方便修改；起爆后-1。这样是70分。
增加ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)，满分。   

题解：
1. 节点存储格子序号、值、左右节点指针。先用vector存储格子序号和值，排序（因为题目没有说输入是有序的），然后建立链表。
2. 建立map存储格子对应的节点的地址，方便快速访问。
3. 易知加水后要可能要起爆的格子只有当前和左右的格子。加水后，检查当前格子，如果要起爆，先删除该节格子，左右节格子水+1，然后递归检查左右格子。
4. 易知起爆过的格子不会再有水，所以让m表示当前有水的格子数。每起爆一个格子，m-1。每次输出m即可。


代码：

```cpp

#include <bits/stdc++.h>
using namespace std;

typedef struct node {
	int index = 0;
	int value = 0;
	node *left = nullptr;
	node *right = nullptr;
} w , *wp;

int c,m,n;
wp head;
map <int,wp> mp;

void deal_boom(wp aim){ // 递归方式处理左右可能要爆炸的格子
	if(aim == head || aim == nullptr) return ;
	if(aim->value>=5){
		aim->value = 0,m -= 1;
		wp lf = aim->left,rt = aim->right;
		if(lf)	lf->right = aim->right, lf->value +=1;
		if(rt) 	rt->left = aim->left, rt->value +=1;
		
		deal_boom(lf),deal_boom(rt);
	}
	return ;
}
void add_water(int index){ 
	mp[index]->value +=1;
	return ;
}


bool cmp(pair<int,int> a,pair<int,int> b){
	return a.first < b.first;
}

int solve(){
	cin >> c >> m >> n;
	vector <pair<int,int>> v(m);
	for(int i = 0;i<m;i++) cin >> v[i].first >> v[i].second;
	sort(v.begin(),v.end(),cmp);
	
	head = new w();
	wp now = head;
	for(int i = 0;i<m;i++){
		wp new_node = new w { v[i].first,v[i].second, now, nullptr};
		mp[v[i].first] = new_node;
		now->right = new_node;
		now = new_node;
	}

	while(n--){
		int op;
		cin >> op;
		add_water(op);
		deal_boom(mp[op]);
		cout << m << endl;
	}
	return 1;
}

int main(){
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	solve();
	return 0;
}
```


### 第五题 文件夹合并

题解：
合并操作优化是启发式合并，但这道题没有卡这个点，所以遍历即可。

查询深度操作的优化：
每次合并，其所有子节点的深度都-1。对于这种区间操作容易联想到差分，用前缀和获得深度。这样虽然修改使用差分，从O(n)优化为O(1)，但是查询使用前缀和，从O(1)变为O(n)。

这就需要解决两个问题，1. 如何将 树 转化为 数组 ，便于计算差分和前缀和 2. 如何优化前缀和查询

对于1，我们需要用到DFS序，将树转化为数组。
DFS序比较简单，略。

对于2，用`树状数组`来维护差分数组的前缀和。

在本题中，树状数组可视为差分数组的一种“分区“的前缀和数组。它并不直接存储差分数组从第1位到第n位的完整前缀和，而是将差分数组划分为多个区间，每个节点存储一个区间内的部分和。
在查询前缀和时，只需合并若干个互不重叠的区间节点所对应的值；而在修改某一位置时，仅需更新所有包含该位置的区间的节点。这样查询和修改被优化至 O(log n)。
树状数组的构造、查询、修改，请查看 资料P160
我的代码中定义差分数组为每次深度修改的值，所以输出深度时是 nodes[u].depth + change 。


代码：
```cpp

#include <bits/stdc++.h>
using namespace std;

struct node {
    long long data;
    vector<int> children;
    int in, out;
    int depth;
};

vector<node> nodes;
vector<int> tree;
int dfs_time = 0;

void dfs(int u, int dep) {
    nodes[u].in = ++dfs_time;
    nodes[u].depth = dep;

    for (int v :  nodes[u].children) dfs(v, dep + 1);

    nodes[u].out = dfs_time;
}

int lowbit(int x){
	return (x & -x);
}

void add(int x, int v,int n) {
    for (; x <= n; x += lowbit(x)) tree[x] += v;
}

int query(int x) {
    int s = 0;
    for (; x; x -= lowbit(x)) s += tree[x];
    return s;
}

void range_add(int l, int r, int v,int n) {
    add(l, v,n);
    if (r < n) add(r + 1, -v,n);
}


int main() {
    ios::sync_with_stdio(false);cin.tie(0);

    int n, m;
    cin >> n >> m;
    nodes.resize(n + 1);
    tree.resize(n+1,0);

    for (int i = 2; i <= n; i++) {
        int p;
        cin >> p;
        nodes[p].children.push_back(i);
    }

    for (int i = 1; i <= n; i++) cin >> nodes[i].data;

    dfs(1, 1);

    while (m--) {
        int op, u;
        cin >> op >> u;
        if (op == 1) {
			vector <int > new_children;
            for (int child : nodes[u].children) {
            	nodes[u].data += nodes[child].data;

			    for(int grandchild : nodes[child].children) new_children.push_back(grandchild);

			}
			nodes[u].children = new_children;

            for (int v : nodes[u].children) range_add(nodes[v].in, nodes[v].out, -1,n);

            cout << nodes[u].children.size() << " " << nodes[u].data << '\n';
        } 
		else {
            int change = query(nodes[u].in);
            cout << nodes[u].depth + change << '\n';
        }
    }

    return 0;
}
```




## 第35次CCF计算机软件能力认证
### 第二题 字符串变化
字符串按照字符转换规则进行ki次转换，求转换后的结果。
容易联想到类似快速幂的做法，即：先求出转换 1,2,4,8,16 ... 次的转换规则，然后对于ki次转换，尽可以快速得出结果。

代码中 mp[{x,j}] 代表 x 字符再第j次转换后的字符。
代码：

```cpp


#include <bits/stdc++.h>
using namespace std;

map <pair<int,int> , int> mp;

void solve(int ki){
	if(ki == (ki&-ki)) return ;
	for(int x = 0;x<200;x++) mp[{x,ki}] = x;

	int i = 0,k = ki;
	while(k){
		if(k&1) for(int x=0;x<200;x++) mp[{x,ki}] = mp[ {mp[{x,ki}], 1<<i}];
		i+=1,k = k>>1;
	}
}

int main() {
	string o;
	getline(cin,o);
	int n,k;
	scanf("%d\n",&n);
	
	for(int x = 0;x<200;x++){
		mp[{x,1}] = x;
		mp[{x,0}] = x;
	}	

	while(n--){
		string line;
		getline(cin,line);
		mp[{(int)line[1],1}] = (int)line[2];
	}
	// init
	for(int i = 1;i<=30;i++)
		for(int x = 0;x<200;x++)
			mp[{x,1<<i}] = mp[{mp[{x,1<<(i-1)}],1<<(i-1)} ];

	cin >> k;
	while(k--){
		int ki;
		cin >> ki;
		solve(ki);
		
		for(char i : o)cout << (char)mp[{i,ki}]; 
		cout << '\n';
	}
	return 0;
}
```

## 第36次CCF计算机软件能力认证
### 第二题 梦境巡查

题解：
假设初始为0，每次行走后记录能量，得到结果energy_state[]，可能为负。易知，若要走完，必须弥补相应的的能量缺口，也就是需要0-min(energy_state) 的初始能量，注意初始能量不能为负。
失去 $b _i$ 后，i 后面的energy_state减少 $b _i$，i 前的则不变。为了求min(energy_state[])，对当前位置 i ，两个数组分别存储i的前缀最小值和i的后缀最小值，后缀最小值减去 $b _i$ 后，取两者中较小的，得到结果W(i)。
代码：
```cpp

#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    int a[n+1],b[n+1],energy_state[n+2],reverse_mn[n+2],forward_mn[n+2];
    for (int i = 0; i <= n; i++) cin >> a[i];
    b[0] = 0;
    for (int i = 1; i <= n; i++) cin >> b[i];

    energy_state[0] = 0,energy_state[1] = -a[0];
    for (int i = 2; i <= n + 1; i++) energy_state[i] = energy_state[i - 1] + b[i - 1] - a[i - 1];
    

    reverse_mn[n + 1] = energy_state[n + 1];
    for (int i = n; i > 0; i--) reverse_mn[i] = min(reverse_mn[i + 1], energy_state[i]);

    forward_mn[0] = energy_state[0];
    for (int i = 1; i <= n + 1; i++) forward_mn[i] = min(forward_mn[i - 1], energy_state[i]);
    

    for (int i = 2; i <= n + 1; i++) {
        cout << max({ -forward_mn[i - 1], -(forward_mn[i] - b[i - 1]), 0 }) << " ";
    }

    return 0;
}
```




### 第三题 缓存模拟

题解：
LRU算法：
用链表来表示块使用先后顺序。操作块后，块挪到最前面；替换时替换最后的块。
map关联内存块编号和缓存块地址，快速访问。
算法流程：
对于内存中的块，送入对应的缓存组中。
对于每个缓存组，判断是否在组中：
在：
    更新块，并移动到最前面
不在：
    1. 缓存未满：在最前面加入块
    2. 缓存已满：块移动到最前面

我的代码中合并了“不在”的两种情况，初始生成长度为n的链表，增加头、尾节点，每次删除尾节点前的块，增加头节点后的块，而不是移动块。

代码：

```cpp

#include <bits/stdc++.h>
using namespace std;

struct CacheBlock {
    int num = -1;
    int write = 0;
    CacheBlock* prev = nullptr;
    CacheBlock* next = nullptr;
};

struct CacheGroup {
    CacheBlock* lru_head = new CacheBlock();
    CacheBlock* lru_tail = new CacheBlock();
    map <int, CacheBlock*> index;

    CacheGroup(int n) { 
        CacheBlock * now = lru_head;
        while(n--){
            now->next = new CacheBlock{-1,0,now,nullptr};
            now = now->next;
        }
        now->next = lru_tail;
        lru_tail->prev = now;
    }

    void move_head(CacheBlock* op_block){
        op_block->prev->next = op_block->next;
        op_block->next->prev = op_block->prev;
        
        op_block->prev = lru_head;
        op_block->next = lru_head->next;

        lru_head->next = op_block;
        op_block->next->prev = op_block;
    
        return ;
    }
    
    vector<pair<int, int>> insert(int op, int num) {
        if (index.count(num)) {
            CacheBlock* op_block = index[num];
            op_block->write = op_block->write || op;
            move_head(op_block);
            return {};
        }
    
        vector<pair<int, int>> result;
        CacheBlock * op_block = lru_tail->prev;

        if (op_block->write) result.push_back({1, op_block->num});
        result.push_back({0, num});
    
        index.erase(op_block->num);
        move_head(op_block);
    
        op_block->num = num;
        op_block->write = op;
        index[num] = op_block;
        return result;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, N, q;
    cin >> n >> N >> q;
    vector<CacheGroup> groups;
    for (int i = 0; i < N; i++) {
        groups.push_back(CacheGroup(n));
    }
    while (q--) {
        int op, num;
        cin >> op >> num;
        int group_index = (num / n) % N; 
        auto res = groups[group_index].insert(op, num);
        for (auto& p : res) {
            cout << p.first << " " << p.second << "\n";
        }
    }
    return 0;
}
```



### 第四题 跳房子

题解：
暴力法：建树，指向可能走到的节点，BFS求最短距离。 
优化思路：每个节点 i 的要搜索 i+1 ~  i+k[i] 的节点，许多节点被重复访问，要避免重复访问。
方法1：
rmax记录访问过的最右节点，(i+1)节点搜索范围从 max(rmax,i+1+1) 开始 。

方法2：
并查集。并查集的根节点为未被访问的节点，并查集f[i] 表示从i 向右第一个未被访问的节点。对于节点 i，搜索时，指向下一个未被访问的节点 j ，并且通过 f[j] = find(j+1) 更新并查集，标记f[j]为已访问，并更新距离。节点 j 需要回退到j -a[j]，根据最短路原理，以后所有的需要退回到j-a[j]的节点，一定不是最短路，可以标记为已访问。

代码
```cpp

#include <bits/stdc++.h>
using namespace std;

vector<int> a, k, dist, f;
vector<vector<int>> back;
int n;

int find(int x) {
    if (f[x] == x) return x;
    f[x] = find(f[x]);
    return f[x];
}

int Ufind() {
	queue <int> q;
	dist[1] = 0;
	q.push(1);
	
	while(!q.empty()){
		int x = q.front();
		q.pop();
		int l = x + 1;
		int r = min(x + k[x],n);
		if(l>r) continue;
		
		int cur = l;
		while(cur<=r){
			int e = find(cur);
			if(e > r) break;
			int st = a[e];
			if(dist[st] == -1) {
				dist[st] = dist[x] +1;
				q.push(st);
				for(int backto : back[st] ){
					f[backto] = find(backto+1);
				}
			}
			f[e] = find(e+1);
			cur = e + 1;
		} 
		
	}
	return dist[n];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    cin >> n;
    a.resize(n + 1);k.resize(n + 1);dist.assign(n + 1, -1);
	f.resize(n + 2);back.resize(n + 1);
    
    for (int i = 1; i <= n; i++) {
    	cin >> a[i];
        a[i] = i - a[i];
        
        if (a[i] >= 1 && a[i] <= n) back[a[i]].push_back(i);
        f[i] = i;
    }
    f[n + 1] = n + 1;
    
    for (int i = 1; i <= n; i++) cin >> k[i];
    
    int ans = Ufind();
    cout << ans;
    
    return 0;
}
```


## 第37次CCF计算机软件能力认证
### 第三题 模版展开

题解：
- 思路：
    1. 只存储长度即可，无需维护字符串
    2. 递归计算变量长度时，可能过深，每次计算使用记忆化存储
    3. 输入的读入可以用stringstream来实现。

- 踩过的坑：
    1. 一个变量的赋值类型可能改变，注意更新
    2. 更新赋值类型时，要等计算结束后再更新
    3. 记忆化存储每次要清空
    4. 输出记得取模
    5. 间接赋值中也可能存在“字符串”，可以直接加到长度中，计算时加上这部分长度

一些解释：
为方便阅读，我用引号来区分目标变量和 操作变量/操作字符串
1. 递归可能过深：
比如
```
1 a "a"
2 b "$a"
2 c "$b" "$a"
2 d "$a" "$a" "$a"
3 d
```

此时，如果要计算 d，那么a、b会重复计算，所以需要记忆化存储。

2. 更新赋值类型时，要等所有操作结束后再更新
比如
```
1 a "a"
2 b "a" "$a"
1 b "b" "b"
3 b
```
如果直接把b的类型更新为1，那么计算b时就只考虑"a",而没有考虑 "$a"




代码：
```cpp

#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

LL mod = 1000000007;

typedef struct node {
    string name;
    int type; 
    LL length; 
    vector<node *> access; 

    node(string n) : name(n), type(1), length(0) {}
} node;

map<string, node*> mp;
map<string,LL>mp_mem;

LL cnt_var(node* now) {
    if (now->type == 1) return now->length;
    if (mp_mem.count(now->name)) return mp_mem[now->name];
    
    LL sum = now->length;
    for (node* j : now->access) sum = (sum + cnt_var(j)) % mod;
    
    mp_mem[now->name] = sum;
    return sum;
}

vector<string> get_vars() {
    string line,temp;
    getline(cin, line);
    stringstream ss(line);
    vector<string> vars;
    while (ss >> temp) {
        vars.push_back(temp);
    }
    return vars;
}

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        int op;
        string aim;
        cin >> op >> aim;
        if (!mp.count(aim)) mp[aim] = new node(aim);
        
        node* aim_ptr = mp[aim];
        vector<string> vars;
        mp_mem.clear();
        
        if (op == 1 || op == 2) vars = get_vars();
        if (op == 1) {
            LL length = 0;
            for (string j : vars) {
                if (j[0] != '$') length = (length + j.size()) % mod;
                else {
                    j = j.substr(1);
                    if (!mp.count(j)) mp[j] = new node(j);
                    
                    length = (length + cnt_var(mp[j])) % mod;
                }
            }
            aim_ptr->type = 1 , aim_ptr->length = length;
            
        } 
        else if(op==2) {
            LL str_len = 0;
            vector<node*> access_list;
            for (string j : vars) {
                if (j[0] != '$') str_len = (str_len + j.size()) % mod;
                else {
                    j = j.substr(1);
                    if (!mp.count(j)) mp[j] = new node(j);
                    access_list.push_back(mp[j]);
                }
            }
            aim_ptr->type = 2,aim_ptr->length = str_len,aim_ptr->access = access_list;
        } 
        else {
            LL result = cnt_var(aim_ptr);
            cout << result % mod << endl;
        }
    }
    return 0;
}

```


### 第四题 集体锻炼

题解：
（定义 max($arr[i]$) = A）
右端点 r 从 1 到 n 枚举，对于每个右端点 r ，左端点 l 从当前 r 向左移动时，[ l,r ] 区间 gcd值 只会单调非增，每次变化 gcd值 至少减半，最多变化 log A 次，这使左端点取值区间 [ 0,r ] 可以被分成 log A 个连续段。每段内所有点，到 r 形成的区间 的 gcd 值相同。维护一个表示这些连续段的分段列表，记录连续段的左端点和gcd值。<$l _{i},g _{i}$>，然后计算每段的答案的贡献值。

当右端点 r 增加时，需更新分段列表。前一个的分段列表记录的是以 r-1 为右端点的区间。为了将 [l_i, r-1] 扩展为 [l_i, r]，gcd值需更新为gcd(arr[r],g i)，并合并具有相同gcd值的段。

代码：
```cpp

#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

LL gcd(LL a, LL b) {
    while (b) { LL t = b; b = a % b; a = t; }
    return a;
}

const LL mod = 998244353;

int main() {
    int n;
    cin >> n;
    vector<LL> a(n + 1);
    for (int i = 1; i <= n; i++) cin >> a[i];
    
    LL ans = 0;
    vector<pair<LL, LL>> segments; // 段列表: (left, gcd_value)
    
    for (LL r = 1; r <= n; r++) {
        vector<pair<LL, LL>> new_segments;
        LL current_gcd = a[r];
        new_segments.push_back({r, current_gcd});
        
        for (auto &seg : segments) {
            LL g = gcd(seg.second, a[r]);
            if (g == current_gcd) new_segments.back().first = seg.first;
            else new_segments.push_back({seg.first, g});
            
			current_gcd = g;
        }
        segments = new_segments;
        
        LL last = r;
        for (auto &seg : segments) {
            LL left_min = seg.first , g_val = seg.second;
            LL count = last - left_min + 1;
            LL sum_l = (last + left_min) * count / 2 % mod;
            ans = (ans + sum_l * r % mod * g_val % mod) % mod;
            last = left_min - 1;
        }
    }
    cout << ans % mod << endl;
    return 0;
}
```




## 第38次CCF计算机软件能力认证
## 第二题 机器人复健指南

脑子抽抽了，竟然想用数学方法做，这其实就是一个简单的bfs。、

## 第三题 消息解码
题解：
先判断消息类型
复杂消息：  
    - 拆分消息，对应转为十进制数
    - 代号解析为字符串，散列值通过查找历史代号映射确定，1位收发标志。
    - 根据标志排列收发方，并将解析的代号及散列值存入历史代号映射。
简单消息：
  - 拆分消息，对应转为十进制数
  - 对于前两个代号，如果是典型代号就解析为字符串，否则从历史代号映射中查找对应的代号。
  - 位置编号非0时输出。
- 输出：接收方代号、发送方代号、位置编号（可选）。推断代号前加#，无法推断时用###。


代码：
```cpp

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
map <int,char> daihao;
map <int,string> hashed;

void init(){
	for(int i = 1;i<=10;i++) daihao[i] = i+'0'-1;
	for(int i = 11;i<=36;i++) daihao[i] = i-11+'A';
	daihao[37] = '_';
	return ;
}
string decode_complete(ll a){
	string s="";
	while(a){
		if(a%38!=0) s = daihao[a%38] + s;
		a /= 38;
	}
	return s;
}
ll hash_my(ll origin,int n){
	ll hashed =  ( (origin*47055833459)>>(64-n) )  & (~(1<<n)) ;
	return hashed;
}
ll b2d(string s){
	ll sum = 0,j = 1;
	for(int i = s.size()-1;i>=0;i--){
		sum += (s[i]-'0') * j;
		j<<=1;
	}
	return sum;
}


void deal_complex(string message){
 	ll o1_1 = b2d(message.substr(0,58));
 	ll o2_1 = b2d(message.substr(58,12));
	ll choose = message[70]-'0';
	
	string o1 = decode_complete(o1_1);
	string o2 = (hashed.count(o2_1)) ? "#" + hashed[o2_1] :  "###";
	
	if(choose) cout << o1 <<" " <<o2 << endl;
	else cout << o2 <<" " <<o1 << endl;
	ll hashed_25 = hash_my(o1_1,25);
	ll hashed_12 = hash_my(o1_1,12);
	
	hashed[hashed_25] = o1;
	hashed[hashed_12] = o1;
	return ;
}


string decode_short(ll a){
	string s="";
	for(int i = 1;i<=3;i++){
		s = (char)((a%26)+'A') + s ;
		a /=26;
	}
	s = (char)((a%10)+'0') + s ;
	a/=10;
	
	if((a%36) <=9 && (a%36) >=0 ) s = (char)((a%36)+'0') + s ;
	else if((a%36) <=35 && (a%36) >=10) s = (char)(((a%36)-10)+'A') + s ;
	
	a/=36;
	if(a==0) ;
	else if((a%26) <=9 && (a%26) >=0 ) (char)((a%26 - 1)+'0') + s ;
	else if((a%26) <=35 && (a%26) >=10) (char)((a%26)+'A') + s ;
	
	return s;
}
ll decode_pos(string a){
	ll sum = 0;
	ll m = a.size()-1;
	for(char i : a){
		sum += (i-'0') * (1<<m);
		m --;
	}
	return sum;
}

void deal_simple(string message){
 	ll reciver_1 = b2d(message.substr(0,28));
 	ll sender_1 = b2d(message.substr(28,28));
	ll pos = decode_pos(message.substr(56,15));
	
	string reciver , sender ;

	if( (reciver_1 >> 25) >=1 ) reciver = decode_short(reciver_1 - (1<<25));
	else reciver = (hashed.count(reciver_1)) ? "#" + hashed[reciver_1] :  "###";
	
	if( (sender_1 >> 25) >=1 )sender = decode_short(sender_1 - (1<<25))  ;
	else  sender = (hashed.count(sender_1)) ? "#" + hashed[sender_1] :  "###";
	
	cout << reciver << " " << sender << " " ;
	if(pos!=0) cout << pos << " ";
	cout << '\n';
	return ;
}

int main() {
    ios::sync_with_stdio(false);cin.tie(0);
    init();
    int n;
    cin >> n;
    while(n--){
		string s;
		cin >> s;
		if(s[0]=='1') deal_complex(s.substr(1));
		
		else if(s[0]=='0') deal_simple(s.substr(1));

	}
	return 0;
}
```


