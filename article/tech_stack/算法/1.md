<div style="display:none;" class="author">
{
    "subtitle": "CCF CSP 题解",
    "title" : "算法",
    "date" : "2025-2026",
    "description": "CCF CSP 题解",
    "tag" : ["技术","算法"]
}
</div>

## 练习平台
[Acwing](https://www.acwing.com/)

## 2024-05 第33次CCF计算机软件能力认证
### 第三题 化学方程式配平
[题目描述](https://sim.csp.thusaac.com/contest/33/problem/2)

题解：
第一步，将输入转化为二维数组的形式；第二步，高斯消元；第三步，秩小于未知数个数输出"Y"，反之输出"N"。
一些个人的看法：

代码：
```cpp

#include <bits/stdc++.h>
using namespace std;

double eps = 1e-6;

void gaussian(vector < vector <double>> &arr){
	int h = arr.size() , l = arr[0].size();
	
	for(int i =0;i<min(l,h);i++){
		int mh = i;
		for(int j = i+1 ; j<h;j++) if(fabs(arr[j][i]) > fabs(arr[mh][i])) mh = j;
		swap(arr[i],arr[mh]) ;
		
		if(fabs(arr[i][i]) <=eps) continue;
		
		for(int j = l-1;j>=i;j--) arr[i][j] /= arr[i][i];
	
		for(int j = 0;j<h;j++){
			if(j != i){
				double scale = arr[j][i] / arr[i][i];
				for(int k = 0;k<l;k++) arr[j][k] -= arr[i][k] * scale;
			}
		}
	}
}

void init(vector < vector <double>> &arr){
	int n,ptr=0;
	map <string , int> mp;
	
	cin >> n;
	for(int t = 0;t<n;t++){
		string s;
		int i=0;
		
		cin >> s;
		while(i < s.size()){
			string el = ""; int num = 0;
			while('a' <= s[i]  && s[i] <= 'z') el += s[i++];
			while('0' <= s[i]  && s[i] <= '9') num = num*10+(s[i++]-'0');
			
			if(!mp.count(el)){
				mp[el] = ptr++;
				arr.push_back(vector <double> (n));
			} 
			arr[mp[el]][t] = num;
		}
	}
	return ;
}

int  check(vector < vector <double>> &arr){
	int cnt = 0;
	for(vector <double> i : arr){
		int flag  = 0;
		for(double j : i) {
			if(fabs(j) > eps)  flag += 1;
		}
		if(flag > 1) cnt ++;
	}
	return cnt;
}
int main(){
	int t;
	cin >> t;
	while(t--){
		vector < vector <double> > arr;
		init(arr);
		gaussian(arr);
		if(check(arr) > 0) cout << "Y\n";
		else cout << "N\n"; 
	}
	
}

```

### 第四题 十滴水
[题目描述](https://sim.csp.thusaac.com/contest/33/problem/3)

链表优化写法：
设定全局变量存储有水的格子数；map存储每个格子对应的链表节点，方便修改；起爆后-1。这样是70分。
增加ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)，满分。   

题解：
1. 节点存储格子序号、值、左右节点指针。先用vector存储格子序号和值，排序（因为题目没有说输入是有序的），然后建立链表。
2. 建立map存储格子对应的节点，方便快速访问。
3. 加水，易知加水后要可能要起爆的格子只有当前和左右的格子。如果当前格子起爆，先删除该节点，左右节点的水+1，然后递归检查左格子和右格子。
4. 易知起爆的格子不会再有水，所以让m记录有水的格子数，每次起爆后-1。每次操作后输出m即可。


代码：

```cpp

#include <bits/stdc++.h>
using namespace std;

typedef struct node {
	int index = 0;
	int value = 0;
	node *left = nullptr;
	node *right = nullptr;
} w , *wp;

int c,m,n;
wp head;
map <int,wp> mp;

void deal_boom(wp aim){ // 递归方式处理左右可能要爆炸的格子
	if(aim == head || aim == nullptr) return ;
	if(aim->value>=5){
		aim->value = 0,m -= 1;
		wp lf = aim->left,rt = aim->right;
		if(lf)	lf->right = aim->right, lf->value +=1;
		if(rt) 	rt->left = aim->left, rt->value +=1;
		
		deal_boom(lf),deal_boom(rt);
	}
	return ;
}
void add_water(int index){ 
	mp[index]->value +=1;
	return ;
}


bool cmp(pair<int,int> a,pair<int,int> b){
	return a.first < b.first;
}

int solve(){
	cin >> c >> m >> n;
	vector <pair<int,int>> v(m);
	for(int i = 0;i<m;i++) cin >> v[i].first >> v[i].second;
	sort(v.begin(),v.end(),cmp);
	
	head = new w();
	wp now = head;
	for(int i = 0;i<m;i++){
		wp new_node = new w { v[i].first,v[i].second, now, nullptr};
		mp[v[i].first] = new_node;
		now->right = new_node;
		now = new_node;
	}

	while(n--){
		int op;
		cin >> op;
		add_water(op);
		deal_boom(mp[op]);
		cout << m << endl;
	}
	return 1;
}

int main(){
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	solve();
	return 0;
}
```



